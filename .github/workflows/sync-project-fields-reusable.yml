name: Reusable • Sync Issue Form → Project fields

on:
  workflow_call:
    inputs:
      PROJECT_NUMBER:
        required: true
        type: string
      OWNER_LOGIN:
        required: true
        type: string
      PROJECT_SCOPE:
        required: true
        type: string
      DEBUG:
        required: false
        type: string
        default: "false"
    secrets: {}

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      PROJECT_NUMBER: ${{ inputs.PROJECT_NUMBER }}
      OWNER_LOGIN:    ${{ inputs.OWNER_LOGIN }}
      PROJECT_SCOPE:  ${{ inputs.PROJECT_SCOPE }}
      DEBUG:          ${{ inputs.DEBUG }}
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const DEBUG = (process.env.DEBUG || "").toLowerCase() === "true";
            function dlog(title, obj){ if(!DEBUG) return; try{ core.startGroup(String(title)); core.info(typeof obj==="string"?obj:JSON.stringify(obj,null,2)); } finally { core.endGroup(); } }

            const body = context.payload.issue.body || "";
            dlog("Issue body", body);

            function pickBlock(labelPattern, cast=(x)=>x){
              const escaped = labelPattern.replace(/[.*+?^${}|[\]\\]/g,'\\$&').replace(/\s+/g,'\\s+');
              const re = new RegExp(`^###\\s+[^\\n]*?${escaped}[^\\n]*\\n+(?:[\\s\\n]*)([^\\n\\r]+)`,"gmi");
              const m = re.exec(body);
              return m && m[1] ? cast(m[1].trim()) : null;
            }

            const priority  = pickBlock("Priority");
            const storyRaw  = pickBlock("Story Points");
            const iteration = pickBlock("Iteration");
            const startDate = pickBlock("Start date", s => (s.match(/\d{4}-\d{2}-\d{2}/)?.[0] ?? null));
            const endDate   = pickBlock("End date",   s => (s.match(/\d{4}-\d{2}-\d{2}/)?.[0] ?? null));
            const release   = pickBlock("Release");
            dlog("Extraído", {priority, storyRaw, iteration, startDate, endDate, release});

            const validPriority = ["Critical","High","Medium","Low"];
            if (priority && !validPriority.includes(priority)) return core.setFailed(`Priority inválida: "${priority}". Use: ${validPriority.join(", ")}`);

            const storyPts = storyRaw!=null ? Number(String(storyRaw).match(/\d+/)?.[0]) : null;
            const validStoryPoints = [1,3,5,8,13];
            if (storyPts!=null && !validStoryPoints.includes(storyPts)) return core.setFailed(`Story Points inválido: ${storyPts}. Use 1, 3, 5, 8 ou 13.`);

            if (startDate && !/^\d{4}-\d{2}-\d{2}$/.test(startDate)) return core.setFailed(`Start date inválida: "${startDate}". Use YYYY-MM-DD.`);
            if (endDate   && !/^\d{4}-\d{2}-\d{2}$/.test(endDate))   return core.setFailed(`End date inválida: "${endDate}". Use YYYY-MM-DD.`);
            if (startDate && endDate && new Date(startDate) > new Date(endDate)) return core.setFailed(`Start date (${startDate}) > End date (${endDate}).`);

            const projectNumber = parseInt(process.env.PROJECT_NUMBER, 10);
            const owner = process.env.OWNER_LOGIN;

            let projectQuery, projectVars;
            if (process.env.PROJECT_SCOPE === "org") {
              projectQuery = `
                query($owner:String!, $number:Int!){
                  organization(login:$owner){
                    projectV2(number:$number){
                      id
                      fields(first:50){
                        nodes{
                          ... on ProjectV2FieldCommon      { id name dataType }
                          ... on ProjectV2SingleSelectField{ id name options{ id name } }
                          ... on ProjectV2IterationField   { id name configuration{ iterations{ id title } } }
                        }
                      }
                    }
                  }
                }`;
              projectVars = { owner, number: projectNumber };
            } else {
              projectQuery = `
                query($owner:String!, $repo:String!, $number:Int!){
                  repository(owner:$owner, name:$repo){
                    projectV2(number:$number){
                      id
                      fields(first:50){
                        nodes{
                          ... on ProjectV2FieldCommon      { id name dataType }
                          ... on ProjectV2SingleSelectField{ id name options{ id name } }
                          ... on ProjectV2IterationField   { id name configuration{ iterations{ id title } } }
                        }
                      }
                    }
                  }
                }`;
              projectVars = { owner, repo: context.repo.repo, number: projectNumber };
            }

            const projRes = await github.graphql(projectQuery, projectVars);
            const project = process.env.PROJECT_SCOPE === "org" ? projRes.organization.projectV2 : projRes.repository.projectV2;
            if (!project) throw new Error("Project não encontrado. Confira OWNER_LOGIN / PROJECT_NUMBER / PROJECT_SCOPE.");

            const fields = project.fields.nodes || [];
            const byName = n => fields.find(f => f.name?.toLowerCase() === n.toLowerCase());

            const fPriority  = byName("Priority");
            const fStory     = byName("Story Points");
            const fIteration = byName("Iteration");
            const fStart     = byName("Start date");
            const fEnd       = byName("End date");
            const fRelease   = byName("Release");

            const contentId = context.payload.issue.node_id;
            let itemId = null;
            try {
              const addRes = await github.graphql(`
                mutation($projectId:ID!, $contentId:ID!){
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item{ id } }
                }`, { projectId: project.id, contentId });
              itemId = addRes?.addProjectV2ItemById?.item?.id || null;
            } catch (e) { dlog("addProjectV2ItemById falhou (talvez já exista)", String(e)); }

            if (!itemId) {
              const findItemRes = await github.graphql(`
                query($contentId:ID!){
                  node(id:$contentId){
                    ... on Issue { projectV2Items(first:50){ nodes{ id project{ id title number } } } }
                    ... on PullRequest { projectV2Items(first:50){ nodes{ id project{ id title number } } } }
                  }
                }`, { contentId });
              const items = findItemRes?.node?.projectV2Items?.nodes || [];
              itemId = items.find(n => n.project?.id === project.id)?.id || null;
            }
            if (!itemId) throw new Error("Não consegui obter itemId do Project para esta issue.");

            async function setSingleSelect(field, label){
              if (!field || !label) return;
              const opt = field.options.find(o => o.name?.trim().toLowerCase() === String(label).trim().toLowerCase());
              if (!opt) return core.setFailed(`Opção "${label}" não existe em "${field.name}".`);
              await github.graphql(`
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:ID!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){ projectV2Item{ id } }
                }`, { projectId: project.id, itemId, fieldId: field.id, opt: opt.id });
            }

            async function setNumber(field, value){
              if (!field || value == null || value === "") return;
              const num = Number(value); if (Number.isNaN(num)) return;
              await github.graphql(`
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $num:Float!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ number:$num }
                  }){ projectV2Item{ id } }
                }`, { projectId: project.id, itemId, fieldId: field.id, num });
            }

            async function setDate(field, dateStr){
              if (!field || !dateStr) return;
              await github.graphql(`
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $date:Date!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ date:$date }
                  }){ projectV2Item{ id } }
                }`, { projectId: project.id, itemId, fieldId: field.id, date: dateStr });
            }

            async function setText(field, text){
              if (!field || !text) return;
              await github.graphql(`
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $text:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ text:$text }
                  }){ projectV2Item{ id } }
                }`, { projectId: project.id, itemId, fieldId: field.id, text });
            }

            async function setIteration(field, iterTitle){
              if (!field || !iterTitle) return;
              const it = field.configuration.iterations.find(i => i.title?.trim().toLowerCase() === String(iterTitle).trim().toLowerCase());
              if (!it) return core.setFailed(`Iteração "${iterTitle}" não existe em "${field.name}".`);
              await github.graphql(`
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $iter:ID!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ iterationId:$iter }
                  }){ projectV2Item{ id } }
                }`, { projectId: project.id, itemId, fieldId: field.id, iter: it.id });
            }

            await setSingleSelect(fPriority,  priority);
            await setNumber      (fStory,     storyPts);
            await setIteration   (fIteration, iteration);
            await setDate        (fStart,     startDate);
            await setDate        (fEnd,       endDate);
            await setText        (fRelease,   release);

            core.info("✅ Sincronização concluída com sucesso!");
            return "OK";
